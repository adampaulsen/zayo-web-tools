// HP CSV Cleanup Tool - JavaScript Implementation
// Replicates the functionality of the Excel VBA macro

class HPCSVCleaner {
    constructor() {
        this.originalData = [];
        this.processedData = [];
        this.stats = {
            originalRows: 0,
            filteredRows: 0,
            removedDuplicates: 0,
            finalRows: 0
        };
        
        this.targetCompanies = [
            "AKAMAI INC", "AMAZON", "AMAZON DATA SERVICES; INC", "AMAZON RETAIL; LLC", 
            "AMAZON.COM", "VADATA INC", "GOOGLE INC - PO 4100317072", "GOOGLE", 
            "GOOGLE LLC - PO 4100285053", "ALPHABET DBA GOOGLE LLC", "GOOGLE INC", 
            "GOOGLE INC - PO 4100022562", "GOOGLE LLC", "Facebook", "FACEBOOK INC", 
            "AKAMAI TECHNOLOGIES", "AKAMAI TECHNOLOGIES INC", "AMAZON CORPORATE LLC", 
            "META PLATFORMS; INC.", "AKAMAI", "A100", "A100 US LLC", "VADATA", 
            "Meta", "Tech Mahindra", "Bloomberg", "MICROSOFT CORPORATION", 
            "MICROSOFT", "GOOGLE-HOLDING BAN ONLY"
        ];
        
        this.initializeEventListeners();
    }

    initializeEventListeners() {
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const downloadBtn = document.getElementById('downloadBtn');
        const clearBtn = document.getElementById('clearBtn');

        // Click to upload
        uploadArea.addEventListener('click', () => fileInput.click());
        
        // File input change
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                this.processMultipleFiles(Array.from(e.target.files));
            }
        });

        // Drag and drop
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                this.processMultipleFiles(Array.from(e.dataTransfer.files));
            }
        });

        // Download button
        downloadBtn.addEventListener('click', () => this.downloadCSV());

        // Clear Results button
        if (clearBtn) {
            clearBtn.addEventListener('click', () => this.clearResults());
        }
    }

    async processMultipleFiles(files) {
        try {
            this.showProcessing();
            this.updateProgress(5, `Reading ${files.length} file(s)...`);
            this.originalData = [];
            let allProcessed = [];
            let totalOriginalRows = 0;
            let totalRemovedDuplicates = 0;
            let emptyFiles = [];

            for (let i = 0; i < files.length; i++) {
                this.updateProgress(5 + Math.floor(80 * i / files.length), `Processing file ${i+1} of ${files.length}...`);
                const text = await this.readFileAsText(files[i]);
                const data = this.parseCSV(text);
                totalOriginalRows += data.length;
                const cleaned = this.applyTransformations(data);
                totalRemovedDuplicates += this.stats.removedDuplicates;
                allProcessed = allProcessed.concat(cleaned);
                if (cleaned.length === 0) {
                    // Extract SPLICE-XXXXXX from file name
                    const match = files[i].name.match(/SPLICE-\d{6}/i);
                    if (match) {
                        emptyFiles.push(match[0].toUpperCase());
                    } else {
                        emptyFiles.push(files[i].name);
                    }
                }
            }

            // Remove duplicates across all files based on column 3 (now index 2 after inserting D)
            const seen = new Set();
            const uniqueRows = [];
            for (const row of allProcessed) {
                if (row.length > 2) {
                    const key = row[2];
                    if (!seen.has(key)) {
                        seen.add(key);
                        uniqueRows.push(row);
                    }
                }
            }
            this.processedData = uniqueRows;
            this.stats.originalRows = totalOriginalRows;
            this.stats.filteredRows = allProcessed.length;
            this.stats.removedDuplicates = totalRemovedDuplicates + (allProcessed.length - uniqueRows.length);
            this.stats.finalRows = uniqueRows.length;

            this.updateProgress(95, 'Finalizing...');
            this.updateStats();
            this.updateProgress(100, 'Complete!');
            setTimeout(() => {
                this.showResults();
                this.displayPreview();
                this.displayEmptyFiles(emptyFiles);
            }, 500);
        } catch (error) {
            console.error('Error processing files:', error);
            alert('Error processing files: ' + error.message);
            this.hideProcessing();
        }
    }

    async processFile(file) {
        try {
            this.showProcessing();
            this.updateProgress(10, 'Reading file...');
            
            // Read the file
            const text = await this.readFileAsText(file);
            this.updateProgress(20, 'Parsing CSV...');
            
            // Parse CSV
            this.originalData = this.parseCSV(text);
            this.stats.originalRows = this.originalData.length;
            this.updateProgress(40, 'Applying filters...');
            
            // Apply the same transformations as the Excel macro
            this.processedData = this.applyTransformations(this.originalData);
            this.updateProgress(80, 'Finalizing...');
            
            // Update stats
            this.updateStats();
            this.updateProgress(100, 'Complete!');
            
            // Show results
            setTimeout(() => {
                this.showResults();
                this.displayPreview();
            }, 500);
            
        } catch (error) {
            console.error('Error processing file:', error);
            alert('Error processing file: ' + error.message);
            this.hideProcessing();
        }
    }

    readFileAsText(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = (e) => reject(new Error('Failed to read file'));
            reader.readAsText(file);
        });
    }

    parseCSV(text) {
        const lines = text.split('\n');
        const data = [];
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line) {
                // Simple CSV parsing - split by comma but handle quoted values
                const row = this.parseCSVLine(line);
                data.push(row);
            }
        }
        
        return data;
    }

    parseCSVLine(line) {
        const result = [];
        let current = '';
        let inQuotes = false;
        
        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            
            if (char === '"') {
                inQuotes = !inQuotes;
            } else if (char === ',' && !inQuotes) {
                result.push(current.trim());
                current = '';
            } else {
                current += char;
            }
        }
        
        result.push(current.trim());
        return result;
    }

    applyTransformations(data) {
        let processed = [...data];
        
        // Step 1: Remove first row (equivalent to Rows("1:1").Select and Delete)
        processed = processed.slice(1);
        this.updateProgress(50, 'Removing header row...');
        
        // Step 2: Delete columns F and G (indices 5 and 6 in 0-based)
        processed = processed.map(row => {
            const newRow = [...row];
            newRow.splice(5, 2); // Remove columns F and G
            return newRow;
        });
        this.updateProgress(60, 'Removing columns F and G...');

        // Normalize all fields: trim whitespace and tabs
        processed = processed.map(row => row.map(cell => (cell || '').replace(/\t/g, '').trim()));

        // Step 3: Filter for Dark Fiber types in column 6 (now index 5 after removing F and G), case-insensitive
        processed = processed.filter(row => {
            if (row.length <= 5) return false;
            const fiberType = (row[5] || '').toLowerCase();
            return fiberType === 'dark fiber - lh' || fiberType === 'dark fiber - metro';
        });
        this.updateProgress(65, 'Filtering Dark Fiber types...');

        // Step 4: Filter for target companies in column 7 (now index 6), case-insensitive and trimmed
        const normalizedTargetCompanies = this.targetCompanies.map(c => c.toLowerCase().trim());
        processed = processed.filter(row => {
            if (row.length <= 6) return false;
            const company = (row[6] || '').toLowerCase().trim();
            return normalizedTargetCompanies.includes(company);
        });
        this.updateProgress(70, 'Filtering target companies...');
        
        // Step 5: Insert new column D (insert at index 3)
        processed = processed.map(row => {
            const newRow = [...row];
            newRow.splice(3, 0, ''); // Insert empty column D
            return newRow;
        });
        this.updateProgress(75, 'Inserting column D...');
        
        // Step 6: Remove duplicates based on column 3 (now index 2 after inserting D)
        const seen = new Set();
        const uniqueRows = [];
        
        for (const row of processed) {
            if (row.length > 2) {
                const key = row[2]; // Column 3 (0-based index 2)
                if (!seen.has(key)) {
                    seen.add(key);
                    uniqueRows.push(row);
                }
            }
        }
        
        this.stats.removedDuplicates = processed.length - uniqueRows.length;
        processed = uniqueRows;
        
        return processed;
    }

    updateStats() {
        this.stats.filteredRows = this.processedData.length;
        this.stats.finalRows = this.processedData.length;
        
        document.getElementById('originalRows').textContent = this.stats.originalRows;
        document.getElementById('filteredRows').textContent = this.stats.filteredRows;
        document.getElementById('removedDuplicates').textContent = this.stats.removedDuplicates;
        document.getElementById('finalRows').textContent = this.stats.finalRows;
    }

    displayPreview() {
        const header = document.getElementById('previewHeader');
        const body = document.getElementById('previewBody');
        
        // Clear previous content
        header.innerHTML = '';
        body.innerHTML = '';
        
        if (this.processedData.length === 0) {
            body.innerHTML = '<tr><td colspan="10" style="text-align: center; padding: 2rem;">No data matches the filters</td></tr>';
            return;
        }
        
        // Create header
        const headerRow = document.createElement('tr');
        const csvHeaders = [
            'Sheath',
            'Fiber',
            'DFID',
            '', // Untitled column
            'SO Facility/Circuit ID',
            'Network Facility',
            'Product Group',
            'Customer'
        ];
        for (let i = 0; i < csvHeaders.length; i++) {
            const th = document.createElement('th');
            th.textContent = csvHeaders[i];
            headerRow.appendChild(th);
        }
        header.appendChild(headerRow);
        
        // Create preview rows (show first 10 rows)
        const previewRows = this.processedData.slice(0, 10);
        
        previewRows.forEach(row => {
            const tr = document.createElement('tr');
            
            for (let i = 0; i < maxCols; i++) {
                const td = document.createElement('td');
                td.textContent = row[i] || '';
                tr.appendChild(td);
            }
            
            body.appendChild(tr);
        });
        
        if (this.processedData.length > 10) {
            const moreRow = document.createElement('tr');
            const moreCell = document.createElement('td');
            moreCell.colSpan = maxCols;
            moreCell.textContent = `... and ${this.processedData.length - 10} more rows`;
            moreCell.style.textAlign = 'center';
            moreCell.style.fontStyle = 'italic';
            moreCell.style.color = '#6b7280';
            moreRow.appendChild(moreCell);
            body.appendChild(moreRow);
        }
    }

    downloadCSV() {
        if (this.processedData.length === 0) {
            alert('No data to download');
            return;
        }
        // Add header row
        const header = [
            'Sheath',
            'Fiber',
            'DFID',
            '', // Untitled column
            'SO Facility/Circuit ID',
            'Network Facility',
            'Product Group',
            'Customer'
        ];
        // Convert data back to CSV format, with header
        const csvContent = this.convertToCSV([header, ...this.processedData]);
        // Create download link
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', 'cleaned_hp_data.csv');
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    convertToCSV(data) {
        return data.map(row => 
            row.map(cell => {
                // Escape quotes and wrap in quotes if contains comma or quote
                const escaped = String(cell).replace(/"/g, '""');
                if (escaped.includes(',') || escaped.includes('"') || escaped.includes('\n')) {
                    return `"${escaped}"`;
                }
                return escaped;
            }).join(',')
        ).join('\n');
    }

    showProcessing() {
        document.getElementById('uploadArea').style.display = 'none';
        document.getElementById('processingSection').style.display = 'block';
        document.getElementById('resultsSection').style.display = 'none';
    }

    hideProcessing() {
        document.getElementById('uploadArea').style.display = 'block';
        document.getElementById('processingSection').style.display = 'none';
    }

    showResults() {
        document.getElementById('uploadArea').style.display = 'none';
        document.getElementById('processingSection').style.display = 'none';
        document.getElementById('resultsSection').style.display = 'block';
    }

    updateProgress(percentage, text) {
        document.getElementById('progressFill').style.width = percentage + '%';
        document.getElementById('progressText').textContent = text;
    }

    displayEmptyFiles(emptyFiles) {
        const listDiv = document.getElementById('emptyFilesList');
        const ul = document.getElementById('emptyFilesUl');
        if (emptyFiles && emptyFiles.length > 0) {
            listDiv.style.display = 'block';
            ul.innerHTML = '';
            emptyFiles.forEach(id => {
                const li = document.createElement('li');
                li.textContent = id;
                ul.appendChild(li);
            });
        } else {
            listDiv.style.display = 'none';
            ul.innerHTML = '';
        }
    }

    clearResults() {
        // Reset all data and stats
        this.originalData = [];
        this.processedData = [];
        this.stats = {
            originalRows: 0,
            filteredRows: 0,
            removedDuplicates: 0,
            finalRows: 0
        };
        // Reset UI
        document.getElementById('uploadArea').style.display = 'block';
        document.getElementById('processingSection').style.display = 'none';
        document.getElementById('resultsSection').style.display = 'none';
        // Reset stats display
        document.getElementById('originalRows').textContent = '0';
        document.getElementById('filteredRows').textContent = '0';
        document.getElementById('removedDuplicates').textContent = '0';
        document.getElementById('finalRows').textContent = '0';
        // Clear preview table
        document.getElementById('previewHeader').innerHTML = '';
        document.getElementById('previewBody').innerHTML = '';
        // Also clear file input value so the same file can be re-uploaded
        document.getElementById('fileInput').value = '';
        // Clear empty files list
        this.displayEmptyFiles([]);
    }
}

// Initialize the application when the page loads
document.addEventListener('DOMContentLoaded', () => {
    new HPCSVCleaner();
}); 